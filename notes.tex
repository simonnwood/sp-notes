\documentclass[10pt] {article}
\usepackage{epsf}
\usepackage{latexsym}
\usepackage[T1]{fontenc}
\usepackage{makeidx,epsfig,lscape}
\usepackage{natbib}
\usepackage{rotating}
\usepackage{floatpag}
\rotfloatpagestyle{empty}
\usepackage{graphicx}
\usepackage{graphics}
\usepackage{epsf}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{latexsym}
\usepackage{comment}
\usepackage{bm}
\usepackage{times}
\setlength{\textheight}{22.5cm}
\setlength{\textwidth}{16cm}
\setlength{\oddsidemargin}{-5mm}
\setlength{\topmargin}{-0.8cm}
\setlength{\evensidemargin}{-5mm}
\usepackage{listings}
\newcommand{\grad}{\nabla}
\newcommand{\tr}[1]{\text{tr}(#1)}
\newcommand{\bp}{{\vm \beta}}
\newcommand{\X}{{\vf X}}
\newcommand{\E}{E}
\newcommand{\vf}{\bf} %% vector type-setting
\newcommand{\vm}{\bm} %% vector type-setting
\newcommand{\ts}{^{\rm T}}
\newcommand{\its}{^{-\rm T}}
\newcommand{\bmat}[1]{\left [ \begin{array}{#1}}
\newcommand{\emat}{\end{array}\right ]}
\newcommand{\eps}[3]
{{\begin{center}
 \rotatebox{#1}{\scalebox{#2}{\includegraphics{#3}}}
 \end{center}}
}
\DeclareMathOperator*{\argmin}{argmin}
\DeclareMathOperator*{\argmax}{argmax} %% original {arg\,max} to space arg max
\lstset{language=R,
        basicstyle={\ttfamily\small},
        keywordstyle=,
        showstringspaces=false,
        columns=flexible}

%% Definitions
\newcommand {\hide}[1] {\typeout{ #1 }}
%Comment out to print all
%\newcommand {\hide}[1] {{\it #1 }}
%Comment out to hide some
\newcommand{\beq}{\begin{equation}}
\newcommand{\eeq}{\end{equation}}
\newcommand{\dif}[2]{\frac{{\rm d} #1}{{\rm d} #2}}
\newcommand{\ildif}[2]{{\rm d} #1/{{\rm d} #2 }}
\newcommand{\ilpdif}[2]{\partial #1/{\partial #2 }}
\newcommand{\pdif}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\pddif}[3]{\frac{\partial^2 #1}{\partial #2 \partial #3}}
\newcommand{\ilpddif}[3]{\partial^2 #1/{\partial #2 \partial #3}}
\newcommand{\comb}[2]{\left (\begin{array}{c}{#1}\\{#2}\end{array}\right )}
\newcommand{\gfrac}[2]{\mbox{$ { \textstyle{ \frac{#1}{#2} }\displaystyle}$}}
\newcommand{\R}{{\sf R }}
\theoremstyle{definition}
  \newtheorem*{definition}{Definition}
  \newtheorem*{example}{Example}
%\newcommand{\vm}{\bm}
% comment out next line unless double spacing needed
%\renewcommand{\baselinestretch}{2}

\newtheorem{theorem}{Theorem}


\begin {document}

\centerline{\huge \bf Statistical Programming}

\tableofcontents


\section{Software Requirements: R, git, JAGS etc}

To complete this course you will need to get yourself a free github account and install the following software on your computer: 
\begin{itemize}
\item R or Rstudio, git, pandoc and JAGS.
\item R packages: ggplot2, rjags, rmarkdown, debug.
\item Only if you do not already have latex installed, install tinytex. 
\end{itemize}
It is assumed that you have the basic computer skills to do this. If not, you will need to spend some time online acquiring them (this course is about programming, not basic computer skills). If you have difficulty, you can post questions on piazza for other students to answer. Please answer other student's questions on installation on piazza. 

In more detail.
\begin{itemize}
\item R is the free statistical programming language and environment that we will use. You can get a copy from the Comprehensive R Archive Network (CRAN)\\
\verb+https://cran.r-project.org/+\\
just follow the links under `Download and Install R'. 
\item Rstudio is an alternative front end for R, which many people prefer to use. It provides an R code editor, R session window, R graphics window and other information, all in a convenient `integrated environment'. If you prefer this to R as available from CRAN, you can get it from\\
\verb+https://www.rstudio.com/+\\
at the foot of the page, under `R studio desktop'. 
\item git is a version control system. It helps you to write code in teams, as you must do for this course, without breaking each others work. It also lets you keep a record of the changes you make, so that you can go back to earlier versions, if you need to. To install {\tt git} follow the instructions at\\
\verb+https://www.git-scm.com/+\\
On Windows use the default options. {\tt linux} systems often have it installed already and something like \verb+sudo apt install git+ will install it if not. 
\item For Mac or linux you also need to install the Git Credential Manager Core (this is automatically installed for Windows). Instructions are at:\\
{\scriptsize \verb+https://docs.github.com/en/get-started/getting-started-with-git/caching-your-github-credentials-in-git+}\\
Linux is slightly fiddly (I used the plain text option 4 for credential storage). 
\item pandoc is document conversion software used by the {\tt rmarkdown} package. Installation instructions:\\
\verb+https://pandoc.org/installing.html+ 
\item JAGS stands for `Just Another Gibbs Sampler'. We will use it for programming Bayesian models and sampling from them. Downloads are available here:\\
\verb+https://sourceforge.net/projects/mcmc-jags/files/JAGS/4.x/+\\
but under linux something like \verb+sudo apt install jags+ can be used. Note that if you have a new apple/mac with an apple silicon processor (rather than intel), then you will need to install MacPorts from\\ 
\verb+https://www.macports.org/install.php+\\
then install JAGS as described here\\
\verb+https://ports.macports.org/port/jags/+
\end{itemize}

Once the above are installed, you will need to install some packages from the R session command line. R/Rstudio can install packages in a local directory/folder for you, but I tend to start R as administrator/super user/root and then install them (e.g. on linux I would start R from the command line as \verb+sudo R+). Here are the packages you need:
\begin{itemize}
\item ggplot2 provides a nice alternative to built in R graphics. Install by typing\\
\verb+install.packages("ggplot2")+\\
at the R command line.
\item rmarkdown provides a neat way of documenting data analyses using R. Install using\\
 \verb+install.packages("rmarkdown")+
\item rjags lets you use JAGS directly from R. Install using\\
 \verb+install.packages("rjags")+
\item Finally we need a debugging package, to help you to find errors in your code, or understand how code is working by stepping through it. What is built into R and Rstudio is not great, and a much better option is Mark Bravington's debug package. This is not available from CRAN, but only from Mark's repository, so to install, you need to do this:
\begin{verbatim}
options(repos=c("https://markbravington.github.io/Rmvb-repo",
        getOption( "repos")))
install.packages("debug")
\end{verbatim}
\item rmarkdown requires a latex installation in order to allow you to produce pdf documents. So, {\em only if you do not already have latex installed}, install {\tt tinytex} with
\verb+install.packages("tinytex")+
then if you are {\em really sure} that you do not already have latex installed run 
\verb+tinytex::install_tinytex()+
WARNING: this command may break existing latex installations!
\end{itemize}
Once you have the software installed, you need to do one more thing. Get a free github account (if you do not already have one).  \verb+https://github.com/join+ is where to get one. 


\subsection{Using a terminal window, choose a text editor}

This course involves programming - that is writing text instructions that get a computer to do something. Anyone who programmes rapidly discovers that writing text to get a computer to do something is often quicker, more convenient and more reproducible than clicking your way through a graphical interface. This sometimes true even for basic tasks such as file copying, or moving between directories/folders. 

Whatever operating system you are using you will be able to launch a `terminal window' for this purpose. Make sure that for your operating system you know how to do this, how to list the names of the files in a directory/folder, how to change from one directory/folder to another, how to delete a file, and how to close the terminal window. 

You will also need to edit text files containing the computer code you write. If you choose to use Rstudio, there is a built in editor, and you might choose to just use that. If you use plain R then you will need an external editor. Word is not suitable, as it will insert hidden characters in your code that will cause problems, so you instead should use something simpler (e.g. wordpad or notepad on windows). Make sure you know what is available on your computer and use that. I tend to use emacs, but this has more features than you actually need for this course. 

\section{git and github}

{\tt git} is a system that lets you track changes in code files and to manage those files when several people are working on them. In particular it lets you maintain a central {\em repository} of your code, which serves as the backed up master copy. The repository is just a folder/directory containing the master copy of your code. Several people can make working local copies of the repository (on their own computers) and work on the code, and git provides the tools to allow management of the master copy in a way that avoids or resolves conflicts. A conflict is when two people made contradictory changes to the code. 

\subsection{Setting up a repo on {\tt github}}

An easy way to set up a central repository is to use {\tt github}.  
\begin{itemize}
\item Login to your github account on {\tt github.com}, click on {\tt Repositories} and then click on {\tt New} to set up a new repository.
\item Follow the instructions. You probably want your repository to be private if it is for working on assessed coursework.
\end{itemize}
For group homework, one person sets up the repo and invites their team mates to collaborate on it. 
\begin{itemize}
\item Log on to github, nagivate to your repo, and click on {\tt Settings}.
\item Click on {\tt Manage Access} from the left hand menu, and then on {\tt Invite a collaborator} - you will need their github user name. 
\end{itemize}
You can add files directly to your repo, via the web interface, but we will shortly cover how to add files to the local copy of your repo, and then {\em push} them to github. 

\subsection{Using {\tt git}}

Mostly, you will interact with your github repo via the {\tt git} software, and your local copy of your github repo. You will use {\tt git} by typing commands in a terminal window. To check everything is working before using {\tt git} for the first time you might open a terminal window and check the {\tt git} version, a follows :
\begin{verbatim}
git --version
\end{verbatim}
This gives the answer \verb+git version 2.25.1+ for me. Here we will cover only the most basic use of {\tt git} and {\tt github}: the minimum needed to collaborate on projects and keep your work backed up. You can find much more at:
\begin{itemize}
\item \verb+https://git-scm.com/docs/gittutorial+
\item \verb+https://guides.github.com/+
\item \verb+https://training.github.com/+
\end{itemize}
Note that {\tt Rstudio} offers built in facilities for using {\tt github}, which you may find useful. However before using them it is better to first learn how {\tt git} and {\tt github} work by using them in the way described here, which is transferable to any project, not just R programming with {\tt Rstudio}.  

Before moving on, if you are using a Mac or linux you probably want to issue the command:
\begin{verbatim}
git config --global core.autocrlf input
\end{verbatim}
which deals with the fact that line ends are dealt with differently by different operating systems and handles this gracefully (Windows is set to do this by default).

\subsubsection{Making a local working copy of the repo}

After creating your github repo you need to make a local copy of it on your computer. 
\begin{itemize}
\item From your {\tt github} repo page (at {\tt github.com}) click on {\tt Code} select {\tt Clone} and copy the {\tt htpps} address for the repository that appears. For example, for my repo containing these notes, the address is \verb+https://github.com/simonnwood/sp-notes.git+
\item In the terminal window on your local machine change directory ({\tt cd}) to the folder where you would like the local repo to be located. Then type {\tt git clone} followed by the address you copied. e.g. 
\begin{verbatim}
git clone https://github.com/simonnwood/sp-notes.git
\end{verbatim}
\end{itemize}
A local copy of the repo is then created on your computer. 

\subsection{Modifying work and synchronising with the github repo}

The local copy of your repo is just a directory/folder containing the files in your repo, and a hidden {\tt .git} subdirectory that {\tt git} uses to maintain an index of the files that it should keep track of, and the history of changes made. {\tt git} knows about all the files in the {\tt github} repo you cloned, but will only start keeping track of other files that you may add to your local repo when you tell it to do so (with \verb+git add+). 

Similarly {\tt git} does not keep a record of all the changes you make to your code as you work on it. Rather, it takes and stores a `snapshot' of the state of the files it is tracking only when you tell it to, using a {\tt git commit} command. 

Neither does {\tt git} automatically save all these snapshots to your master {\tt github} repo. That only happens when you tell it to using {\tt git push}. This is quite useful, you can keep a detailed record of the changes you make while working on code locally, without modifying the {\tt github} master repo until you are satisfied that the changes are complete and working.   

Note that you can access the help pages for the main {\tt git} commands by typing {\tt git help} followed by the command name. For example, if you want to know more about {\tt git add} type
\begin{verbatim}
git help add
\end{verbatim}

\subsubsection{Simple work cycle}

Suppose we want to make some code changes in a file \verb+foo.r+ that already exists in the master repo. A typical work sequence would be as follows.
\begin{enumerate}
\item  Change directory ({\tt cd}) to the local repo. 
\item If collaborating with others, you might want to make sure that you local repo is up to date with the master copy on {\tt github}, using \verb+git pull+ to get (`pull') any changes from {\tt github}. (\verb+git diff @{upstream}+ can be used to view the changes first, if you prefer.) 
\item Work on {\tt foo.r} until you are happy with the changes made, and have tested them. 
\item Have {\tt git} take a snapshot of the changes made using something like 
\begin{verbatim}
git commit -a -m"added a wibbleblaster to foo.r"
\end{verbatim}  
The \verb+-a+ option tells {\tt git} to take a snapshot of every file that it is tracking that you have changed. If you omit \verb+-a+ then you must tell {\tt git} which files you want it to snapshot explicitly, for example using \verb+git add foo.r+, before committing. The option \verb+-m+ adds a message describing the changes. If you omit the \verb"-m" then {\tt git} will open an editor, in which you enter the message - this can be useful if you want to include a longer set of comments. These comments can be viewed on the {\tt github} repo, providing a useful record of what the individual code changes were for.  
\item Now `push' the changes to {\tt github}. 
\begin{verbatim}
git push
\end{verbatim}
If only you are working on the code, then you will be done at this point, but if others are working on it at the same time, then the {\tt push} command may fail because your new code conflicts with the code someone else has pushed to {\tt github} since you last pulled the repo. How to fix this is described next. 
\end{enumerate} 

Note that \verb+git log+ lets you view the commit history of your project (to review what has been done and why).

\subsubsection{Simple conflict resolution}

If your {\tt git push} command fails (and it will tell you if it has!) then you need to resolve the conflict. This is not so hard. 

\begin{enumerate}
\item After your {\tt git push} command has failed, issue the command
\begin{verbatim}
git pull
\end{verbatim}
This will get the latest versions of the files from the {\tt github} repo, compare them to your local copies, and attempt to resolve conflicts automatically where possible. Where auto-fixing is not possible, it will modify your local copies so that whenever there is a conflict your local files contain both your code and the conflicting code from the {\tt github} master, with clear marking of which is which. 
\item You check the conflicting files, changing the code to resolve any remaining flagged conflicts (often just selecting one or other of the alternative). 
\item Now redo the commit and push steps
\begin{verbatim}
git commit -a -m"resolved conflict in favour of small end cracking"
git push
\end{verbatim} 
If this fails because a teammate has meanwhile made another change, you really need to sort out your team communication - {\tt git} can't do that for you. 
\end{enumerate}

\subsubsection{Adding and deleting files with {\tt git}}

You can add as many files as you like to your local copy of the repo, but {\tt git} will take no notice of them until you tell it to. For example, suppose you created a file {\tt bar.r} which should be treated as part of the project, tracked and included in the master repo on {\tt qithub}
\begin{verbatim}
git add bar.r
git commit -a -m"added file bar.r containing the gribbler code"
git push
\end{verbatim}
(You could omit the \verb+-a+ in this case, as the preceding \verb+add+ command will ensure \verb+bar.r+ is included in the next commit.)

You might also want to remove files, of course. 
\begin{verbatim}
git rm bar.r
\end{verbatim}
deletes {\tt bar.r} from the local copy, and will cause it to be removed from the master repo at the next {\tt commit} and {\tt push}.

\subsection{More advanced use}

The above covers the most basic use of {\tt git}. It is sufficient for working on small projects in small teams on this course, and for understanding the basic principles of version control systems. We have not covered some key components of  
{\tt git} and {\tt github} that are extremely useful for larger projects. In particular we have not covered project {\em branches}. {\tt git} allows you to simultaneously have several versions of your project ({\em  branches}) in addition to the master version. These versions can all be tracked and backed up, just as the main master branch is. 

A typical use of branches is to code and work on complicated modifications - tracking and backing up the changes in those modifications, while not modifying the main project until is is clear that the modified code is really working and ready to be merged into the main project. 

To give a concrete example, suppose you maintain a large R package, which relies on code written in C and Fortran, and you decide that it would be advantageous to replace all the Fortran code with C code. This is a major undertaking, and you would not want to simply start work on the stable working code for the main package, since this will almost certainly break it initially. That would be a real nuisance if you then needed to deal with a minor bug in the original package, but had only the half completed unstable modified code available. Much better to create a branch of the project on which to develop the new C based code, only merging into the maser branch, once everything in the revision is fully working.  

\subsection{A simple {\tt git}/{\tt github} exercise}

At this stage, it is essential that you try out git and github. So before reading on try the following exercise. If you are not sure how to do any part, then refer back to the material above that you have just read.
\begin{enumerate}
\item Using a web browser, set yourself up a new repo on {\tt github}, and edit the default {\tt README.md} file on {\tt github} to say something interesting (making sure to save and commit the change).
\item Clone your {\tt github} repo to your local machine.
\item Add a file to your local repo, edit it and add it to the files tracked by {\tt git}.
\item Commit your edits and push the repo to {\tt github}.
\item Check that the repo on {\tt github} now contains your newly added file. 
\item As soon as you know someone else on the course to work with, try out sharing repositories, and resolving conflicts.
\end{enumerate}


\section{Programming for statistical data analysis}

Programming is the process of writing instructions to make a computer perform some task. The instructions have to be written in standard way that both the programmer and the computer can interpret. The rules and key words defining such a standard way of communicating define a computer language. There are many alternative languages designed for different classes of task. Here we will concentrate on the R language (and environment) for programming with data, which is widely used for the statistical analysis of data. A huge amount of statistical analysis software is written in R and is freely available. 

{\em Statistical} analysis of data is concerned with the analysis of data that is in some sense a random {\em sample} from a larger {\em population}. We want to learn about the population from the sample, without being misled by particular features of the sample that arose by chance as part of the random sampling process. The random sampling approach is powerful because: 
\begin{enumerate}
\item it allows reliable conclusions with known levels of accuracy to be drawn without having to gather data from the whole population, which may be impossible, or prohibitively expensive.       
\item random sampling eliminates the unknowably large bias that occurs if we try to learn about the population from a non-random sample, replacing that bias with a random uncertainty of known magnitude.   
\end{enumerate}
Note that while population here might mean something concrete like `population of people in the UK' it might be much more abstract like `the population of all experimental results that this experiment could have produced when replicated under the same conditions'.

To understand the difference between statistical and non-statistical data analysis consider data on reported cases of Covid-19 each day. Many charts of these data are produced, and analyses are performed, such as producing running averages or looking for trends in the data. None of these analyses are statistical, as no attempt is made to consider what population the case data might be viewed as a random sample of. They are certainly not a random sample of the people who have Covid-19 on a given day, and neither is it remotely clear how the number of cases relates to the number of people with Covid on a particular day.  The government and media present these data {\em as if} they were a random sample from the population of Covid cases, but this is simply misleading. Any decent applied statistician should be able to list several sources of bias likely to occur by treating them as such. 

In contrast, each week in the UK, the Office for National Statistics publishes the results of testing a randomly selected sample of the UK population for Covid. The analysis includes estimates of trends and uncertainties, from a properly statistical analysis. Unsurprisingly the ONS analysis often appears to contradict the naive interpretations of the case data given by the media and government. More surprisingly the media and government seem to give more weight to the non-statistical analyses of case data than to the statistical analyses of the ONS data, despite the latter being essentially unbiased and of known accuracy, while the former have bias of unknown magnitude. Even more surprisingly, the UK appears to be unique in even conducting unbiased sampling to establish Covid prevalence.

The Covid cases example illustrates why statistical analysis software is dangerous. The easier software is to use, the easier it is to produce an analysis of data that resembles a statistical analysis in every superficial respect, but not in the key one that the data are in some sense a random sample from a population.  Beware of this problem.         

\subsection*{Exercise}

The following link is to an article in a national newspaper by two professors of statistics that appeared on 19th April 2020.
{\small \verb+https://www.theguardian.com/commentisfree/2020/apr/19/coronavirus-deaths-data-uk+} 
There is an astonishing statement in the second paragraph. Identify the statement and what is wrong with it.


\section{Getting started with R}

In this course we will concentrate on learning programming skills that as far as possible are transferable to other programming languages in addition to R. For this reason we will largely stick to programming using what is available with R itself, and we will ovoid over-reliance on any particular set of add on packages. There is an add on package providing functions for almost any simple task you might want to accomplish in R. The fact that we will here examine how to programme tasks for which it would be simpler to find an add on package, is not though a desire to re-invent the wheel. The point is not to learn the quickest way to perform the particular task, but rather to illustrate how to programme. 

A word of warning. In much university work, getting something 80\% right is a first class performance. Unfortunately programming is not like that. 80\% right means 20\% wrong, and 20\% wrong computer code will likely result in your programme doing 0\% of what it is supposed to do. This fact calls for a more precise approach to working than is necessary for other topics.  

\subsection{Dissecting a simple programming example}

Let us start with an example, of a simple data manipulation task in R. Suppose that we have a vector of 1 or 2 digit numbers and want to create a new vector of the individual digits, in order. For example if the original vector is $[12,5,23,2]$ the new vector should be $[1,2,5,2,3,2]$. Before trying this we need to write down {\em how} we are going to do it. For example:
\begin{enumerate}
\item Identify the number and locations of the double digit numbers in the original vector (and hence the length of the new vector).
\item Work out the locations of the `tens' digits in the new vector, compute and insert them.
\item Work out the locations of the `units' digits in the new vector and insert them. 
\end{enumerate}
The following is R code for one way of implementing this. It could be typed, line by line into the R console, but it is better to type it into a file and then copy and paste to the R console, or {\tt source} the file into R, or run it in Rstudio. 
\begin{verbatim}
x <- c(10,2,7,89,43,1) ## an example vector to try out
ii <- which(x%/%10 > 0) ## indices of the double digits in x?
xs <- rep(0,length(ii)+length(x)) ## vector to store the single digits
iis <- ii+1:length(ii)-1 ## where should 10s digits go in xs?
xs[iis] <- x[ii]%/%10 ## insert 10s digits
xs[-iis] <- x%%10  ## insert the rest (units)
\end{verbatim}  
Anything after \verb+#+ on a line is ignored by R, so is a comment. It is a good idea to use lots of these. Here is what the code does in detail, line by line.
\begin{enumerate}
\item \verb+x <- c(10,2,7,89,43,1)+ creates an example vector to work on. The {\tt c} function takes the individual numbers supplied to it, and concatenates them into a single vector (it can also concatenate vectors). The results are stored in vector \verb+x+ using the assignment operator \verb+<-+. Notice how {\tt x} is created automatically by this assignment. Unlike in many computer languages, we do not have to declare {\tt x} first. 
\item \verb+ii <- which(x%/%10 > 0)+ creates a vector, {\tt ii} of the indices of the double digit numbers in \verb+x+. It does this by computing the result of integer division by 10, for each element of {\tt x}, using the \verb+%/%+ operator, and then testing whether this result is greater than 0. The result of \verb+x%/%10 > 0+ will be a vector of {\tt TRUE} or {\tt FALSE} values of the same length as {\tt x}. For the given example it is $({\tt TRUE},{\tt FALSE},{\tt FALSE},{\tt TRUE},{\tt TRUE},{\tt FALSE})$. This vector is supplied directly to the {\tt which} function, which returns the indices for which the vector is {\tt TRUE} (1,4 and 5 for the example given). 
\item \verb^xs <- rep(0,length(ii)+length(x))^ creates a vector of zeroes into which the individual digits will be inserted, using the {\tt rep} function. {\tt rep} simply repeats its first argument the number of times specified in its second argument. The {\tt length} function returns the number of elements in an existing vector. We need {\tt xs} to be the length of {\tt x} plus an extra element for each double digit number.
\item \verb^iis <- ii+1:length(ii)-1^ creates a vector, {\tt iis}, containing the indices (locations) of the 10s digits in {\tt xs}. We have to account for the fact that each time we insert a digit, all the digits after move along one place, relative to where they were. So, the first 10s digit will occupy the same slot in {\tt x} and {\tt xs}, but the next 10s digit will be one element later in {\tt xs} than in {\tt x}, the next 2 elements later, and so on. \verb+1:length(ii)-1+ creates a sequence 0,1,2\ldots to add to {\tt ii} to achieve this. It uses the \verb+:+ operator --- if {\tt a} and {\tt b} are integers (and $a<=b$) \verb+a:b+ generates the sequence $a,a+1,a+2,\ldots,b$.
\item \verb+xs[iis] <- x[ii]%/%10+ computes the 10s digits of the double digit numbers, indexed by {\tt ii}, using \verb+x[ii]%/%10+, and assigns them to the elements of {\tt xs} indexed by {\tt iis}.
\item \verb+xs[-iis] <- x%%10+ computes the units digit for all the numbers in {\tt x} using \verb+x%%10+ where \verb+%%+ is the operator computing the remainder after integer division. These digits are stored in the elements of {\tt xs} {\em not} reserved for 10s digits. That is, \verb+xs[-iis]+, all the elements {\em except} those indexed by {\tt iis}. 
\end{enumerate}
Make sure you really understand what this code is doing. Run it one line at a time in R, and examine the result created by each line to make sure you understand exactly what is happening. To see what is in an R object, just type its name at the console, and it will be printed, by default. For example:
\begin{verbatim}
> xs  ## > just denotes the R prompt here
[1] 1 0 2 7 8 9 4 3 1
\end{verbatim}

The preceding example has quite a bit of R packed in, and we used quite a few R functions and operators on the way. R provides a large number of functions for a variety of tasks, and the available add on packages vastly more. You can't hope to learn them all, so it is essential to learn how to use the R help system. This is easy. For any operator of function you know the name of then just type \verb+?+ followed by the function name, or the operator in quotes. For example
\begin{verbatim}
?which ## get the help for the 'which' function
?"<-"  ## get help for the assignment operator
help.start() ## launch html help in a browser
\end{verbatim}  
\ldots the last option is often best if you are not sure what you are looking for.

\subsection{A second simple example: data are not always numbers}

R vectors are not restricted to containing numbers. Character strings are another common data type that we can hold in a vector. For example \verb+x <- c("jane","bill","sue")+ creates a 3-vector, containing the 3 given character strings. Functions are provided for manipulating such character string data in various ways. For the moment suppose we want to achieve the same task as in the previous example, but for the case in which the numbers are supplied as character strings, and we want the separated digits as character strings too\footnote{As the point is to provide illustration of string handling, I'll resist the temptation to use {\tt as.numeric} to convert the character data to numbers, run the previous code, and then use {\tt as.character} to convert back.}.  

We can use more or less the same approach as in the last section, but with one slight modification to the logic. For numbers it was easy to separate out 10s and units, with only the 2 digit numbers having a 10s digit. When the numbers are represented as character strings it is easier to separate out first and second digits, with only the two digit numbers having second digits. This means that rather than finding the indices of 10s digits, we'll find the indices of second digits. Here is the modified code:

\begin{verbatim}
x <- c("10","2","7","89","43","1") ## example vector
ii <- which(nchar(x)>1) ## which elements of x are double digit?
xs <- rep("",length(ii)+length(x)) ## vector to store the single digits
iis <- ii+1:length(ii) ## where should second digit go in xs?
xs[iis] <- substr(x[ii],2,2) ## insert 2nd digits
xs[-iis] <- substr(x,1,1)    ## insert 1st digits
\end{verbatim}
Line by line, here is what it does:
\begin{enumerate}
\item \verb+x <- c("10","2","7","89","43","1")+ example vector, as before, but now of character type.
\item \verb+ii <- which(nchar(x)>1)+ uses the {\tt nchar} function to count the characters in each element of {\tt x}. \verb+which(nchar(x)>1)+ returns the indices for which the corresponding element of {\tt x} was more than one character.
\item  \verb^xs <- rep("",length(ii)+length(x))^ creates {\tt xs} as before, but this time it is a character vector.
\item \verb^iis <- ii+1:length(ii)^ computes the locations for second digits in {\tt xs}. Same idea as before, but second digits are all located one place after the 10s digits.
\item \verb+xs[iis] <- substr(x[ii],2,2)+. Function \verb+substr+ is used to obtain the 2nd character from each 2 digit element of {\tt x} ({\tt ii} indexes the 2 digit elements). \verb+substr(x[ii],2,2)+ extracts the characters between characters 2 and 2, from the elements of {\tt x[ii]} and returns them in a vector, which is copied into the appropriate locations in {\tt xs}.
\item \verb+xs[-iis] <- substr(x,1,1)+ the first digits are then inserted in the locations not reserved for second digits. 
\end{enumerate}

\subsubsection{Another simple text processing task}

The above example is a bit artificial. Let's consider a slightly more realistic task to undertake on character data. Suppose we have a string containing  some `poetry', and we want to count the number of words, tabulate the number of letters per word, count the number of words containing at least one `e' and mark all words containing an `a' and an `e' with a `*'. Here is R code to do this.
\begin{verbatim}
poem <- paste("Inside me is a skeleton, of this I have no doubt,",
        "now it's got my flesh on, but it's waiting to get out.")
pow <- strsplit(poem," ")[[1]] ## vector of poem words
n.words <- length(pow) ## number of words
freq <- tabulate(nchar(pow)) ## count frequency of n-letter words
ie <- grep("e",pow,fixed=TRUE) ## find `e' words
n.e <- length(ie)   ## number of `e' words
ia <- grep("a",pow,fixed=TRUE) ## find `a' words
iea <- ia[ia %in% ie] ## find words with `e' and `a'
pow[iea] <- paste(pow[iea],"*",sep="") ## mark `e' `a' words
paste(pow,collapse=" ") ## and put words back in one string.
\end{verbatim}
Line by line it works like this:
\begin{enumerate}
\item The first line just creates a text string, {\tt poem}, containing the given text. The {\tt paste} function joins the two given strings into one string. The only reason to use it here was to split the string nicely across lines for these notes - we could just as well have written everything in one string to start with.
\item \verb+pow <- strsplit(poem," ")[[1]]+ splits {\tt poem} into a vector of its individual words, using\\ \verb+strsplit(poem," ")+, which splits the string in {\tt poem} at the breaks given by spaces, \verb+" "+. {\tt strsplit} can take a vector of strings as its first argument, and returns a {\em list} of vectors containing the split strings. In our case the list only has one element, which is what the \verb+[[1]]+ part of the code accesses. 
\item \verb+n.words <- length(pow)+ counts the words in {\tt poem}, since there is one element of {\tt pow} per word.
\item \verb+freq <- tabulate(nchar(pow))+ counts how many 1 letter, 2 letter, 3 letter, etc. words are in {\tt poem}. First function {\tt nchar} counts the letters in each word and then {\tt tabulate} tallies them up. Really we should have stripped out punctuation marks first - {\tt gsub} could be used to do this.
\item \verb+ie <- grep("e",pow,fixed=TRUE)+ finds the indices of the words containing an `e' using the {\tt grep} function. By default {\tt grep} can do much more complicated pattern matching using `regular expressions (see {\tt ?regex}), for the moment this is turned off using \verb+fixed=TRUE+ (otherwise characters like \verb+.+ and \verb+*+ are not matched as you might expect, but treated differently).
\item \verb+n.e <- length(ie)+ is the count of `e' words.
\item \verb+ia <- grep("a",pow,fixed=TRUE)+ finds the indices of the words containing an `a'.
\item \verb+iea <- ia[ia %in% ie]+ finds the indices of words containing an `a' and an `e'. \verb+ia %in% ie+ gives a {\tt TRUE} for each element of {\tt ia} that occurs in {ie} and a {\tt FALSE} for each element of {\tt ia} that doesn't. Hence {\tt iea} will contain the indices of the words containing both letters.
\item \verb+pow[iea] <- paste(pow[iea],"*",sep="")+ adds a `*' to each word in {\tt pow} containing an `e' an an `a'. The {\tt paste} function is used for this, with \verb+sep=""+ indicating that no space is wanted between the words and the `*'.
\item \verb+paste(pow,collapse=" ")+ is finally used to put the words in {\tt pow} back into a single string. It is the setting of {\tt collapse} to something non-NULL (here a space) that signals to {\tt paste} that this should happen.
\end{enumerate}


\section{Data re-arrangement and tidy data}

In raw form many data sets are messy and have to be tidied up for statistical analysis. By tidying is meant that the data are re-arranged conveniently for analysis, not that the information in the data is in anyway modified unless an actual error is identified (no removal of outliers, for example). Since `data tidying' or `data re-arrangement' sound too boring and clerical for many enthusiasts for Modern Data Science, you will often hear terms like `data wrangling' and `data munging' used instead. These sound suitably rugged, as if the types engaged in them return home aching and covered in dust and mud after a day engaged in the honest toil of these muscular pursuits.

By tidy data is meant that data are arranged in a matrix so that:
\begin{enumerate}
\item Each column is a variable.
\item Each row is an observation (a unique combination of variables).
\end{enumerate}
and it is recognised that what counts as `an observation' can depend on the subset of variables of interest. For example,
this data frame is in tidy form if interest is in student's grades each week. 
\begin{verbatim}
name    d.o.b.  nationality week grade
George  11/2/01 GB          1    B
George  11/2/01 GB          2    C
George  11/2/01 GB          3    A
Anna    15/6/00 GB          1    A
Anna    15/6/00 GB          2    B
Anna    15/6/00 GB          3    A
.       .       .           .    .
\end{verbatim}
But if we are only interested in birth dates and nationality of students, then we would really want to simplify to
\begin{verbatim}
name    d.o.b.  nationality 
George  11/2/01 GB          
Anna    15/6/00 GB          
.       .       .           
\end{verbatim}
It is easy to get the second data frame form the first (\verb+marks+, say) in base R using
\begin{verbatim}
student <- unique(marks[,c("name","d.o.b.","nationality")])
\end{verbatim}
which has selected the named columns of interest, and then found the unique rows. If you want to refer each row in \verb+marks+ to its row in \verb+student+ then you can use 
\begin{verbatim}
library(mgcv)
student <- unique(marks[,c("name","d.o.b.","nationality")])
ind <- attr(student,"index") ## ind[i] is row of 'student' corresponding to row i of 'marks'
\end{verbatim}

At this point, you are hopefully wondering about replicate data, and the definition of `observation' as `unique combination of variables'? If I repeat an experiment under identical conditions, could I not occasionally get identical results, and hence two identical rows in a data frame that are different observations? Well yes, but only if you do not include a variable recording the `replicate number'. If you don't record the replicate number then you do not really have tidy data, as it is not possible to distinguish the common error of accidental replication of some data, from genuine replicates.

%\makeindex

\end{document}
